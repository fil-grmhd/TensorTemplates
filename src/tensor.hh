//  TensorTemplates: C++ tensor class templates
//  Copyright (C) 2016, Ludwig Jens Papenfort
//                      <papenfort@th.physik.uni-frankfurt.de>
//  Copyright (C) 2017, Elias Roland Most
//                      <emost@th.physik.uni-frankfurt.de>
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#ifndef TENSORS_TENSOR_HH
#define TENSORS_TENSOR_HH

#include <cmath>
#include <type_traits>
#include <tuple>
#include <array>
#include <utility>

#include "tensor_defs.hh"
#include "utilities.hh"
#include "tensor_expressions.hh"

namespace tensors {

template<typename T, typename frame_t_ ,size_t rank_, typename index_t_, size_t ndim_>
class general_tensor_t : public tensor_expression_t<general_tensor_t<T, frame_t_,rank_ , index_t_, ndim_>> {
  public:
    //! Data type
    using data_t = T;
    //! tensor indices encoded in a std::tuple type
    //! In fact we only care about the type here, which should be of size rank
    using  index_t = index_t_;
    //! frame type
    using frame_t = frame_t_;

    //! Rank of the tensor
    static size_t constexpr rank = rank_;//std::tuple_size<index_t>::value;
    //! Number of dimensions
    static size_t constexpr ndim = ndim_;
    //! Number of degrees of freedom
    static size_t constexpr ndof = utilities::static_pow<ndim,rank>::value;

    //! This tensor type
    using this_tensor_t = general_tensor_t<T, frame_t_, rank_, index_t, ndim_>;

  private:
    std::array<T, ndof> m_data {};

  public:
    //C++14 way to completely get around the for loop
    //! Copy constructor
    // CHECK: tensor should be of this_tensor_t in both contructors, which is the only reasonable case.
    //        would probably create ugly template errors in any other case
    // CHECK: is default (autogenerated) move contructor still present?
    template<typename E, std::size_t... I>
    general_tensor_t(tensor_expression_t<E> const& tensor, std::index_sequence<I...>) : m_data({tensor.template evaluate<I>()...}) {
      static_assert(std::is_same<frame_t, typename E::frame_t>::value,
		                "Frame types don't match!");

      static_assert(ndim == E::ndim,
		                "Dimensions don't match!");

      static_assert(rank == E::rank,
		                "Ranks don't match!");

      static_assert(std::is_same<data_t, typename E::data_t>::value,
		                "Data types don't match!");

	    static_assert(compare_index<this_tensor_t,E,rank>(),
		                "Indices do not match!");
    };


    template<typename E, typename Indices = std::make_index_sequence<ndim>>
    general_tensor_t(tensor_expression_t<E> const& tensor) : this_tensor_t(this_tensor_t(tensor,Indices{})) {};

    general_tensor_t() : m_data({0}) {};


    //! Computes the compressed index associated with the given indices
    //! one would need to cusomize this if one wants to implement symmetries
    template<size_t a, size_t... indices>
    static inline constexpr size_t compressed_index() {
      static_assert(rank == sizeof...(indices) + 1,
                    "Number of indices must match rank!");
      static_assert(utilities::all_true<(indices < ndim)...>::value,
                    "Trying to access index > ndim!");

      return compressed_index_t<ndim,a,indices...>::value;
    }

    template<typename tuple_t>
    static inline constexpr size_t compressed_index(tuple_t t){
      return compressed_index_tuple<ndim>(t);
    }


    //! Access the components of a tensor using a compressed index
    /*!
     *  The data is stored in a row major format
     */
    inline T & operator[](size_t const a) {
        return m_data[a];
    }
    //! Access the components of a tensor using a compressed index
    /*!
     *  The data is stored in a row major format
     */
    inline T const & operator[](size_t const a) const {
        return m_data[a];
    }

    //! Evaluation routine for expression templates
    template<size_t index>
    inline T const & evaluate() const {
      return m_data[index];
    }


    // CHECK: element access is only possible with compile-time constants
    //        we should add (i,j,k,...) operator also to the class

    //! Access the components of a tensor using the natural indices
    template<size_t a, size_t... indices>
    inline T & operator()(){
        static_assert(sizeof...(indices)+1 == rank,
            "Number of indices must match rank.");

        return this->operator[](compressed_index<a,indices...>);
    }

    //! Access the components of a tensor using the natural indices
    template<size_t a, size_t... indices>
    inline T const & operator()(){
        static_assert(sizeof...(indices)+1 == rank,
            "Number of indices must match rank.");

        return this->operator[](compressed_index<a,indices...>);
    }

    //! Sets tensor to zero for all components
    inline void zero() {
      for(size_t i = 0; i<ndof; ++i) {
        m_data[i] = 0;
      }
    }
};


} // namespace tensors

#endif
